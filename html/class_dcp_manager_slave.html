<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DCPLib: DcpManagerSlave Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DCPLib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_dcp_manager_slave.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_dcp_manager_slave-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DcpManagerSlave Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for DcpManagerSlave:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_dcp_manager_slave.png" usemap="#DcpManagerSlave_map" alt=""/>
  <map id="DcpManagerSlave_map" name="DcpManagerSlave_map">
<area href="class_abstract_dcp_manager_slave.html" alt="AbstractDcpManagerSlave" shape="rect" coords="0,56,165,80"/>
<area href="class_abstract_dcp_manager.html" alt="AbstractDcpManager" shape="rect" coords="0,0,165,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a450c5955c0fbb1afd3e76ef09bd481a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dcp_manager_slave.html#a450c5955c0fbb1afd3e76ef09bd481a4">DcpManagerSlave</a> (const SlaveDescription_t &amp;dcpSlaveDescription, <a class="el" href="struct_dcp_driver.html">DcpDriver</a> <a class="el" href="class_abstract_dcp_manager.html#abf7df411fccf58a750d870a95df15cc5">driver</a>)</td></tr>
<tr class="separator:a450c5955c0fbb1afd3e76ef09bd481a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0fd3b4a87b829a0a45e958b1526af4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dcp_manager_slave.html#aae0fd3b4a87b829a0a45e958b1526af4">stop</a> () override</td></tr>
<tr class="separator:aae0fd3b4a87b829a0a45e958b1526af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab587893cf3d3e5fa2f890d495010b1d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#ab587893cf3d3e5fa2f890d495010b1d4">gotoErrorHandling</a> ()</td></tr>
<tr class="separator:ab587893cf3d3e5fa2f890d495010b1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cd7c9be4956de5bd375758d07cf02d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a44cd7c9be4956de5bd375758d07cf02d">setError</a> (DcpError errorCode)</td></tr>
<tr class="separator:a44cd7c9be4956de5bd375758d07cf02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013e663381622b04c8da1076b0f12f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a013e663381622b04c8da1076b0f12f1a">gotoErrorResolved</a> ()</td></tr>
<tr class="separator:a013e663381622b04c8da1076b0f12f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590f197cea4792746a6d7b511409b6b4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a590f197cea4792746a6d7b511409b6b4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a590f197cea4792746a6d7b511409b6b4">getInput</a> (uint64_t vr)</td></tr>
<tr class="separator:a590f197cea4792746a6d7b511409b6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28be506f5cb4bf57a735932c929eca41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28be506f5cb4bf57a735932c929eca41"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a28be506f5cb4bf57a735932c929eca41">getOutput</a> (uint64_t vr)</td></tr>
<tr class="separator:a28be506f5cb4bf57a735932c929eca41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754a15f8f48fc625225c15da3f7f691a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a754a15f8f48fc625225c15da3f7f691a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a754a15f8f48fc625225c15da3f7f691a">getParameter</a> (uint64_t vr)</td></tr>
<tr class="separator:a754a15f8f48fc625225c15da3f7f691a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9092385ca110adcaebe34fb6233cd19"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:ae9092385ca110adcaebe34fb6233cd19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#ae9092385ca110adcaebe34fb6233cd19">setPrepareCallback</a> (std::function&lt; void()&gt; prepareCallback)</td></tr>
<tr class="separator:ae9092385ca110adcaebe34fb6233cd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43feb380f8148406b2fc199888ca05d"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:ad43feb380f8148406b2fc199888ca05d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#ad43feb380f8148406b2fc199888ca05d">setConfigureCallback</a> (std::function&lt; void()&gt; configureCallback)</td></tr>
<tr class="separator:ad43feb380f8148406b2fc199888ca05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4306fa0d000c06d3269c2a12e780de06"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a4306fa0d000c06d3269c2a12e780de06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a4306fa0d000c06d3269c2a12e780de06">setSynchronizingNRTStepCallback</a> (std::function&lt; void(uint64_t steps)&gt; synchronizingNRTStepCallback)</td></tr>
<tr class="separator:a4306fa0d000c06d3269c2a12e780de06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea8368b5a0b6ac2e4a148b972c3620d"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a4ea8368b5a0b6ac2e4a148b972c3620d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a4ea8368b5a0b6ac2e4a148b972c3620d">setSynchronizedNRTStepCallback</a> (std::function&lt; void(uint64_t steps)&gt; synchronizedNRTStepCallback)</td></tr>
<tr class="separator:a4ea8368b5a0b6ac2e4a148b972c3620d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82a6ee7cf5faa173564be5f331f0b1f"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:ae82a6ee7cf5faa173564be5f331f0b1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#ae82a6ee7cf5faa173564be5f331f0b1f">setRunningNRTStepCallback</a> (std::function&lt; void(uint64_t steps)&gt; runningNRTStepCallback)</td></tr>
<tr class="separator:ae82a6ee7cf5faa173564be5f331f0b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3060d69b588a60c5e61d6d5577c1a9f"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:af3060d69b588a60c5e61d6d5577c1a9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#af3060d69b588a60c5e61d6d5577c1a9f">setSynchronizingStepCallback</a> (std::function&lt; void(uint64_t steps)&gt; synchronizingStepCallback)</td></tr>
<tr class="separator:af3060d69b588a60c5e61d6d5577c1a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4521dc3951a0d9c4eb09529c50a546c6"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a4521dc3951a0d9c4eb09529c50a546c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a4521dc3951a0d9c4eb09529c50a546c6">setSynchronizedStepCallback</a> (std::function&lt; void(uint64_t steps)&gt; synchronizedStepCallback)</td></tr>
<tr class="separator:a4521dc3951a0d9c4eb09529c50a546c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8029308778fdd61d4632a3463ecf6ca3"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a8029308778fdd61d4632a3463ecf6ca3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a8029308778fdd61d4632a3463ecf6ca3">setRunningStepCallback</a> (std::function&lt; void(uint64_t steps)&gt; runningStepCallback)</td></tr>
<tr class="separator:a8029308778fdd61d4632a3463ecf6ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5df09fdcdbe6b85d19d666cb41cd14"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:ade5df09fdcdbe6b85d19d666cb41cd14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#ade5df09fdcdbe6b85d19d666cb41cd14">setStopCallback</a> (std::function&lt; void(std::thread *runningRoutine)&gt; stopCallback)</td></tr>
<tr class="separator:ade5df09fdcdbe6b85d19d666cb41cd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88f2afdcbdb96bdc20e4205bc5a86f8"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:ae88f2afdcbdb96bdc20e4205bc5a86f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#ae88f2afdcbdb96bdc20e4205bc5a86f8">setInitializeCallback</a> (std::function&lt; void()&gt; initializeCallback)</td></tr>
<tr class="separator:ae88f2afdcbdb96bdc20e4205bc5a86f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac143b1f613b5b457bd935009084a34ce"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:ac143b1f613b5b457bd935009084a34ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#ac143b1f613b5b457bd935009084a34ce">setSynchronizeCallback</a> (std::function&lt; void()&gt; synchronizeCallback)</td></tr>
<tr class="separator:ac143b1f613b5b457bd935009084a34ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db0bf1c90d76979ca16e6c2c1d1d06e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a0db0bf1c90d76979ca16e6c2c1d1d06e">simulationStepFinished</a> ()</td></tr>
<tr class="separator:a0db0bf1c90d76979ca16e6c2c1d1d06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1173f48fe7708ea79872618a764447e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a1173f48fe7708ea79872618a764447e8">prepareFinished</a> ()</td></tr>
<tr class="separator:a1173f48fe7708ea79872618a764447e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cc1527b67cce7c5e1861d43fd8bd51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a34cc1527b67cce7c5e1861d43fd8bd51">configureFinished</a> ()</td></tr>
<tr class="separator:a34cc1527b67cce7c5e1861d43fd8bd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69363c2309a3319722116fa5a95474c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#af69363c2309a3319722116fa5a95474c">stopFinished</a> ()</td></tr>
<tr class="separator:af69363c2309a3319722116fa5a95474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b1890b997417ad1ca52ad3e797d60c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#aa5b1890b997417ad1ca52ad3e797d60c">initializeFinished</a> ()</td></tr>
<tr class="separator:aa5b1890b997417ad1ca52ad3e797d60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835f5efdef75213156c7619af8511325"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a835f5efdef75213156c7619af8511325">synchronizeFinished</a> ()</td></tr>
<tr class="separator:a835f5efdef75213156c7619af8511325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9493656c9fe6fd70a531211046d6f5ed"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a9493656c9fe6fd70a531211046d6f5ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a9493656c9fe6fd70a531211046d6f5ed">setTimeResListener</a> (const std::function&lt; void(uint32_t, uint32_t)&gt; timeResListener)</td></tr>
<tr class="separator:a9493656c9fe6fd70a531211046d6f5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad912dcc8a937d96665957c892e75deab"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:ad912dcc8a937d96665957c892e75deab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#ad912dcc8a937d96665957c892e75deab">setStepsListener</a> (const std::function&lt; void(uint16_t, uint32_t)&gt; stepsListener)</td></tr>
<tr class="separator:ad912dcc8a937d96665957c892e75deab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b162015539fa0b5e343dc145ce9405a"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a5b162015539fa0b5e343dc145ce9405a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a5b162015539fa0b5e343dc145ce9405a">setOperationInformationListener</a> (const std::function&lt; void(uint8_t, DcpOpMode)&gt; operationInformationListener)</td></tr>
<tr class="separator:a5b162015539fa0b5e343dc145ce9405a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d05dfffa5d0f6dd64611f569a37802f"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a2d05dfffa5d0f6dd64611f569a37802f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a2d05dfffa5d0f6dd64611f569a37802f">setConfigurationClearedListener</a> (const std::function&lt; void()&gt; configurationClearedListener)</td></tr>
<tr class="separator:a2d05dfffa5d0f6dd64611f569a37802f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec02dd7eda001f72a6e5aa75095d786c"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:aec02dd7eda001f72a6e5aa75095d786c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#aec02dd7eda001f72a6e5aa75095d786c">setErrorListener</a> (const std::function&lt; void(DcpError)&gt; errorListener)</td></tr>
<tr class="separator:aec02dd7eda001f72a6e5aa75095d786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ab314fa31d51fa04de0767cf8c96c1"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a99ab314fa31d51fa04de0767cf8c96c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a99ab314fa31d51fa04de0767cf8c96c1">setMissingControlPduListener</a> (const std::function&lt; void()&gt; missingControlPduListener)</td></tr>
<tr class="separator:a99ab314fa31d51fa04de0767cf8c96c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472ad7bbcbeb1551e790f190eaf2a996"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a472ad7bbcbeb1551e790f190eaf2a996"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a472ad7bbcbeb1551e790f190eaf2a996">setMissingInputOutputPduListener</a> (const std::function&lt; void(uint16_t)&gt; missingInputOutputPduListener)</td></tr>
<tr class="separator:a472ad7bbcbeb1551e790f190eaf2a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769a7c6710829ba4b1b188e54c1a7396"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a769a7c6710829ba4b1b188e54c1a7396"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a769a7c6710829ba4b1b188e54c1a7396">setMissingParameterPduListener</a> (const std::function&lt; void(uint16_t)&gt; missingParameterPduListener)</td></tr>
<tr class="separator:a769a7c6710829ba4b1b188e54c1a7396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2f19fae7e4aca638110e23d293e65e"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:a9d2f19fae7e4aca638110e23d293e65e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#a9d2f19fae7e4aca638110e23d293e65e">setRuntimeListener</a> (const std::function&lt; void(int64_t)&gt; runtimeListener)</td></tr>
<tr class="separator:a9d2f19fae7e4aca638110e23d293e65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3007f888d6ab81a2b7a9c7de9a57a5c"><td class="memTemplParams" colspan="2">template&lt;FunctionType ftype&gt; </td></tr>
<tr class="memitem:ab3007f888d6ab81a2b7a9c7de9a57a5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager_slave.html#ab3007f888d6ab81a2b7a9c7de9a57a5c">setStateChangedListener</a> (const std::function&lt; void(DcpState)&gt; stateChangedListener)</td></tr>
<tr class="separator:ab3007f888d6ab81a2b7a9c7de9a57a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0ac8d5c5cba5af33400519ce10b6e9ee"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager.html#a0ac8d5c5cba5af33400519ce10b6e9ee">getNextSeqNum</a> (const uint8_t acuId)</td></tr>
<tr class="separator:a0ac8d5c5cba5af33400519ce10b6e9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a66620cb3dfa2191fcc4d3b52ba862f12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dcp_manager_slave.html#a66620cb3dfa2191fcc4d3b52ba862f12">lastExecution</a></td></tr>
<tr class="separator:a66620cb3dfa2191fcc4d3b52ba862f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7df411fccf58a750d870a95df15cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_dcp_driver.html">DcpDriver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager.html#abf7df411fccf58a750d870a95df15cc5">driver</a></td></tr>
<tr class="separator:abf7df411fccf58a750d870a95df15cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23343b0e34aa0137b95cb605fbd0434a"><td class="memItemLeft" align="right" valign="top">std::map&lt; uint8_t, uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager.html#a23343b0e34aa0137b95cb605fbd0434a">segNumsOut</a></td></tr>
<tr class="separator:a23343b0e34aa0137b95cb605fbd0434a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d9975440d2ce14eca95d246fae2bd7"><td class="memItemLeft" align="right" valign="top">std::map&lt; uint8_t, uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager.html#a28d9975440d2ce14eca95d246fae2bd7">segNumsIn</a></td></tr>
<tr class="separator:a28d9975440d2ce14eca95d246fae2bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bff4c44dc2f9b239638974966929b0"><td class="memItemLeft" align="right" valign="top">std::map&lt; uint16_t, uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager.html#a60bff4c44dc2f9b239638974966929b0">dataSegNumsOut</a></td></tr>
<tr class="separator:a60bff4c44dc2f9b239638974966929b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67251f7ad4c2f35eb6db406bfa72d59"><td class="memItemLeft" align="right" valign="top">std::map&lt; uint16_t, uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager.html#ae67251f7ad4c2f35eb6db406bfa72d59">dataSegNumsIn</a></td></tr>
<tr class="separator:ae67251f7ad4c2f35eb6db406bfa72d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1348246d9c74b77cbcde3a16d04bc8"><td class="memItemLeft" align="right" valign="top">std::map&lt; uint16_t, uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager.html#a2f1348246d9c74b77cbcde3a16d04bc8">parameterSegNumsOut</a></td></tr>
<tr class="separator:a2f1348246d9c74b77cbcde3a16d04bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b997c30041c4cc65921f6f71ad6391f"><td class="memItemLeft" align="right" valign="top">std::map&lt; uint16_t, uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_dcp_manager.html#a4b997c30041c4cc65921f6f71ad6391f">parameterSegNumsIn</a></td></tr>
<tr class="separator:a4b997c30041c4cc65921f6f71ad6391f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>DCP mangement of an slave </p><dl class="section author"><dt>Author</dt><dd>Christian Kater <a href="#" onclick="location.href='mai'+'lto:'+'kat'+'er'+'@si'+'m.'+'uni'+'-h'+'ann'+'ov'+'er.'+'de'; return false;">kater<span style="display: none;">.nosp@m.</span>@sim<span style="display: none;">.nosp@m.</span>.uni-<span style="display: none;">.nosp@m.</span>hann<span style="display: none;">.nosp@m.</span>over.<span style="display: none;">.nosp@m.</span>de</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a450c5955c0fbb1afd3e76ef09bd481a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450c5955c0fbb1afd3e76ef09bd481a4">&#9670;&nbsp;</a></span>DcpManagerSlave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DcpManagerSlave::DcpManagerSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveDescription_t &amp;&#160;</td>
          <td class="paramname"><em>dcpSlaveDescription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_dcp_driver.html">DcpDriver</a>&#160;</td>
          <td class="paramname"><em>driver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Instanciate a DCP manager for an slave </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dcpSlaveDescription</td><td>Slave description of the slave </td></tr>
    <tr><td class="paramname">driver</td><td>DCP driver of the slave </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a34cc1527b67cce7c5e1861d43fd8bd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cc1527b67cce7c5e1861d43fd8bd51">&#9670;&nbsp;</a></span>configureFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractDcpManagerSlave::configureFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configure action is finished. </p><dl class="section return"><dt>Returns</dt><dd>True if calling is allowed and action was performed, otherwise False</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A ASYNC callback for setConfigureCallback was called </dd></dl>

</div>
</div>
<a id="a590f197cea4792746a6d7b511409b6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590f197cea4792746a6d7b511409b6b4">&#9670;&nbsp;</a></span>getInput()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T AbstractDcpManagerSlave::getInput </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to a input </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the input. Has to be a pointer. E. g. uint16_t* for uint16. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vr</td><td>Value reference of the input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value of the corresponding input. </dd></dl>

</div>
</div>
<a id="a0ac8d5c5cba5af33400519ce10b6e9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac8d5c5cba5af33400519ce10b6e9ee">&#9670;&nbsp;</a></span>getNextSeqNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t AbstractDcpManager::getNextSeqNum </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>acuId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next sequence number for an given acuId </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acuId</td><td>acuId for which the seq. id. will be returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28be506f5cb4bf57a735932c929eca41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28be506f5cb4bf57a735932c929eca41">&#9670;&nbsp;</a></span>getOutput()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T AbstractDcpManagerSlave::getOutput </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to an output </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the output. Has to be a pointer. E. g. uint16_t* for uint16. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vr</td><td>Value reference of the output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value of the corresponding output. </dd></dl>

</div>
</div>
<a id="a754a15f8f48fc625225c15da3f7f691a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754a15f8f48fc625225c15da3f7f691a">&#9670;&nbsp;</a></span>getParameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T AbstractDcpManagerSlave::getParameter </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to a parameter </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the parameter. Has to be a pointer. E. g. uint16_t* for uint16. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vr</td><td>Value reference of the parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value of the corresponding parameter. </dd></dl>

</div>
</div>
<a id="ab587893cf3d3e5fa2f890d495010b1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab587893cf3d3e5fa2f890d495010b1d4">&#9670;&nbsp;</a></span>gotoErrorHandling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::gotoErrorHandling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Go to state ERRORHANDLING immediatly. The master will be informed by NTF_state_changed. </p>

</div>
</div>
<a id="a013e663381622b04c8da1076b0f12f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013e663381622b04c8da1076b0f12f1a">&#9670;&nbsp;</a></span>gotoErrorResolved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::gotoErrorResolved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Go to state ERRORRESOLVED, if current state is ERRORHANDLING. Indicate that the error is resolved. The master will be informed by NTF_state_changed. </p>

</div>
</div>
<a id="aa5b1890b997417ad1ca52ad3e797d60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b1890b997417ad1ca52ad3e797d60c">&#9670;&nbsp;</a></span>initializeFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractDcpManagerSlave::initializeFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize action is finished. </p><dl class="section return"><dt>Returns</dt><dd>True if calling is allowed and action was performed, otherwise False</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A ASYNC callback for setInitializeCallback was called </dd></dl>

</div>
</div>
<a id="a1173f48fe7708ea79872618a764447e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1173f48fe7708ea79872618a764447e8">&#9670;&nbsp;</a></span>prepareFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractDcpManagerSlave::prepareFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Preparing action is finished. </p><dl class="section return"><dt>Returns</dt><dd>True if calling is allowed and action was performed, otherwise False</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A ASYNC callback for setPrepareCallback was called </dd></dl>

</div>
</div>
<a id="a2d05dfffa5d0f6dd64611f569a37802f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d05dfffa5d0f6dd64611f569a37802f">&#9670;&nbsp;</a></span>setConfigurationClearedListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setConfigurationClearedListener </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>configurationClearedListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the listener for CFG_clear PDUs </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorAckReceivedListener</td><td>function which will be called after the event occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43feb380f8148406b2fc199888ca05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43feb380f8148406b2fc199888ca05d">&#9670;&nbsp;</a></span>setConfigureCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setConfigureCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>configureCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for action followed by a STC_configure PDU </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: configureFinished needs to be called after finishing configuring action </dd></dl>

</div>
</div>
<a id="a44cd7c9be4956de5bd375758d07cf02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cd7c9be4956de5bd375758d07cf02d">&#9670;&nbsp;</a></span>setError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setError </td>
          <td>(</td>
          <td class="paramtype">DcpError&#160;</td>
          <td class="paramname"><em>errorCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the error code </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorCode</td><td>New error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec02dd7eda001f72a6e5aa75095d786c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec02dd7eda001f72a6e5aa75095d786c">&#9670;&nbsp;</a></span>setErrorListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setErrorListener </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(DcpError)&gt;&#160;</td>
          <td class="paramname"><em>errorListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the listener for any error that may occur </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorAckReceivedListener</td><td>function which will be called after the event occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae88f2afdcbdb96bdc20e4205bc5a86f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88f2afdcbdb96bdc20e4205bc5a86f8">&#9670;&nbsp;</a></span>setInitializeCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setInitializeCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>initializeCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for action followed by a STC_initialize PDU </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: initializeFinished needs to be called after finishing preparing action </dd></dl>

</div>
</div>
<a id="a99ab314fa31d51fa04de0767cf8c96c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ab314fa31d51fa04de0767cf8c96c1">&#9670;&nbsp;</a></span>setMissingControlPduListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setMissingControlPduListener </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>missingControlPduListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the listener for missing control PDUs </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorAckReceivedListener</td><td>function which will be called after the event occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a472ad7bbcbeb1551e790f190eaf2a996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472ad7bbcbeb1551e790f190eaf2a996">&#9670;&nbsp;</a></span>setMissingInputOutputPduListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setMissingInputOutputPduListener </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(uint16_t)&gt;&#160;</td>
          <td class="paramname"><em>missingInputOutputPduListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the listener for missing DAT_input_output PDUs </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorAckReceivedListener</td><td>function which will be called after the event occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a769a7c6710829ba4b1b188e54c1a7396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769a7c6710829ba4b1b188e54c1a7396">&#9670;&nbsp;</a></span>setMissingParameterPduListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setMissingParameterPduListener </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(uint16_t)&gt;&#160;</td>
          <td class="paramname"><em>missingParameterPduListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the listener for missing DAT_parameter PDUs </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorAckReceivedListener</td><td>function which will be called after the event occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b162015539fa0b5e343dc145ce9405a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b162015539fa0b5e343dc145ce9405a">&#9670;&nbsp;</a></span>setOperationInformationListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setOperationInformationListener </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(uint8_t, DcpOpMode)&gt;&#160;</td>
          <td class="paramname"><em>operationInformationListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the listener for CFG_time_res PDUs </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorAckReceivedListener</td><td>function which will be called after the event occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9092385ca110adcaebe34fb6233cd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9092385ca110adcaebe34fb6233cd19">&#9670;&nbsp;</a></span>setPrepareCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setPrepareCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>prepareCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for action followed by a STC_prepare PDU </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: prepareFinished needs to be called after finishing preparing action </dd></dl>

</div>
</div>
<a id="ae82a6ee7cf5faa173564be5f331f0b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82a6ee7cf5faa173564be5f331f0b1f">&#9670;&nbsp;</a></span>setRunningNRTStepCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setRunningNRTStepCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint64_t steps)&gt;&#160;</td>
          <td class="paramname"><em>runningNRTStepCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for a step in state RUNNING and operation mode NRT </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: simulationStepFinished needs to be called after finishing configuring action </dd></dl>

</div>
</div>
<a id="a8029308778fdd61d4632a3463ecf6ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8029308778fdd61d4632a3463ecf6ca3">&#9670;&nbsp;</a></span>setRunningStepCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setRunningStepCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint64_t steps)&gt;&#160;</td>
          <td class="paramname"><em>runningStepCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for a realtime step in state RUNNING and operation mode SRT or HRT </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: simulationStepFinished needs to be called after finishing configuring action </dd></dl>

</div>
</div>
<a id="a9d2f19fae7e4aca638110e23d293e65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2f19fae7e4aca638110e23d293e65e">&#9670;&nbsp;</a></span>setRuntimeListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setRuntimeListener </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(int64_t)&gt;&#160;</td>
          <td class="paramname"><em>runtimeListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the listener for STC_run PDUs </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorAckReceivedListener</td><td>function which will be called after the event occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3007f888d6ab81a2b7a9c7de9a57a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3007f888d6ab81a2b7a9c7de9a57a5c">&#9670;&nbsp;</a></span>setStateChangedListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setStateChangedListener </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(DcpState)&gt;&#160;</td>
          <td class="paramname"><em>stateChangedListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the listener for state changes which was made by the dcp slave manager </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorAckReceivedListener</td><td>function which will be called after the event occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad912dcc8a937d96665957c892e75deab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad912dcc8a937d96665957c892e75deab">&#9670;&nbsp;</a></span>setStepsListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setStepsListener </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(uint16_t, uint32_t)&gt;&#160;</td>
          <td class="paramname"><em>stepsListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the listener for CFG_steps PDUs </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorAckReceivedListener</td><td>function which will be called after the event occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade5df09fdcdbe6b85d19d666cb41cd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5df09fdcdbe6b85d19d666cb41cd14">&#9670;&nbsp;</a></span>setStopCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setStopCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(std::thread *runningRoutine)&gt;&#160;</td>
          <td class="paramname"><em>stopCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for action followed by a STC_stop PDU </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: stopFinished needs to be called after finishing preparing action </dd></dl>

</div>
</div>
<a id="ac143b1f613b5b457bd935009084a34ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac143b1f613b5b457bd935009084a34ce">&#9670;&nbsp;</a></span>setSynchronizeCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setSynchronizeCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>synchronizeCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for action followed by a STC_synchronize PDU </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: synchronizeFinished needs to be called after finishing preparing action </dd></dl>

</div>
</div>
<a id="a4ea8368b5a0b6ac2e4a148b972c3620d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea8368b5a0b6ac2e4a148b972c3620d">&#9670;&nbsp;</a></span>setSynchronizedNRTStepCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setSynchronizedNRTStepCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint64_t steps)&gt;&#160;</td>
          <td class="paramname"><em>synchronizedNRTStepCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for a step in state SYNCHRONIZED and operation mode NRT </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: simulationStepFinished needs to be called after finishing configuring action </dd></dl>

</div>
</div>
<a id="a4521dc3951a0d9c4eb09529c50a546c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4521dc3951a0d9c4eb09529c50a546c6">&#9670;&nbsp;</a></span>setSynchronizedStepCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setSynchronizedStepCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint64_t steps)&gt;&#160;</td>
          <td class="paramname"><em>synchronizedStepCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for a realtime step in state SYNCHRONIZED and operation mode SRT or HRT </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: simulationStepFinished needs to be called after finishing configuring action </dd></dl>

</div>
</div>
<a id="a4306fa0d000c06d3269c2a12e780de06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4306fa0d000c06d3269c2a12e780de06">&#9670;&nbsp;</a></span>setSynchronizingNRTStepCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setSynchronizingNRTStepCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint64_t steps)&gt;&#160;</td>
          <td class="paramname"><em>synchronizingNRTStepCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for a step in state SYNCHRONIZING and operation mode NRT </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: simulationStepFinished needs to be called after finishing configuring action </dd></dl>

</div>
</div>
<a id="af3060d69b588a60c5e61d6d5577c1a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3060d69b588a60c5e61d6d5577c1a9f">&#9670;&nbsp;</a></span>setSynchronizingStepCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setSynchronizingStepCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint64_t steps)&gt;&#160;</td>
          <td class="paramname"><em>synchronizingStepCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback for a realtime step in state SYNCHRONIZING and operation mode SRT or HRT </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>ftype SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prepareCallback</td><td>function which will be called after the event occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>IF ftype == ASYNC: simulationStepFinished needs to be called after finishing configuring action </dd></dl>

</div>
</div>
<a id="a9493656c9fe6fd70a531211046d6f5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9493656c9fe6fd70a531211046d6f5ed">&#9670;&nbsp;</a></span>setTimeResListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FunctionType ftype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractDcpManagerSlave::setTimeResListener </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(uint32_t, uint32_t)&gt;&#160;</td>
          <td class="paramname"><em>timeResListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the listener for CFG_time_res PDUs </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ftype</td><td>SYNC means calling the given function is blocking, ASYNC means non blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorAckReceivedListener</td><td>function which will be called after the event occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0db0bf1c90d76979ca16e6c2c1d1d06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db0bf1c90d76979ca16e6c2c1d1d06e">&#9670;&nbsp;</a></span>simulationStepFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractDcpManagerSlave::simulationStepFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A simulation step is finished.</p>
<dl class="section return"><dt>Returns</dt><dd>True if calling is allowed and action was performed, otherwise False</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A ASYNC callback for set{Synchronizing, Synchronized, Running}{"", NRT}Callback was called </dd></dl>

</div>
</div>
<a id="aae0fd3b4a87b829a0a45e958b1526af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0fd3b4a87b829a0a45e958b1526af4">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DcpManagerSlave::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stops the slave if possible </p><dl class="section return"><dt>Returns</dt><dd>True means slave switched to state STOPPING, false means no action done </dd></dl>

<p>Implements <a class="el" href="class_abstract_dcp_manager_slave.html#ae65e441602f6ce65525e1de292748dcf">AbstractDcpManagerSlave</a>.</p>

</div>
</div>
<a id="af69363c2309a3319722116fa5a95474c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69363c2309a3319722116fa5a95474c">&#9670;&nbsp;</a></span>stopFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractDcpManagerSlave::stopFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stop action is finished. </p><dl class="section return"><dt>Returns</dt><dd>True if calling is allowed and action was performed, otherwise False</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A ASYNC callback for setStopCallback was called </dd></dl>

</div>
</div>
<a id="a835f5efdef75213156c7619af8511325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835f5efdef75213156c7619af8511325">&#9670;&nbsp;</a></span>synchronizeFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractDcpManagerSlave::synchronizeFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronize action is finished. </p><dl class="section return"><dt>Returns</dt><dd>True if calling is allowed and action was performed, otherwise False</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A ASYNC callback for setSynchronizeCallback was called </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae67251f7ad4c2f35eb6db406bfa72d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67251f7ad4c2f35eb6db406bfa72d59">&#9670;&nbsp;</a></span>dataSegNumsIn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;uint16_t, uint16_t&gt; AbstractDcpManager::dataSegNumsIn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>last seq. id which was received </p>

</div>
</div>
<a id="a60bff4c44dc2f9b239638974966929b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bff4c44dc2f9b239638974966929b0">&#9670;&nbsp;</a></span>dataSegNumsOut</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;uint16_t, uint16_t&gt; AbstractDcpManager::dataSegNumsOut</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>last seq. id which was send out </p>

</div>
</div>
<a id="abf7df411fccf58a750d870a95df15cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7df411fccf58a750d870a95df15cc5">&#9670;&nbsp;</a></span>driver</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_dcp_driver.html">DcpDriver</a> AbstractDcpManager::driver</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DCP Driver instance </p>

</div>
</div>
<a id="a66620cb3dfa2191fcc4d3b52ba862f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66620cb3dfa2191fcc4d3b52ba862f12">&#9670;&nbsp;</a></span>lastExecution</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DcpManagerSlave::lastExecution</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Upcounting id for last execution. Is used to determine if between an longer operation, e.g. initializing, an state change has happened and the done calculations are obsolete. </p>

</div>
</div>
<a id="a4b997c30041c4cc65921f6f71ad6391f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b997c30041c4cc65921f6f71ad6391f">&#9670;&nbsp;</a></span>parameterSegNumsIn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;uint16_t, uint16_t&gt; AbstractDcpManager::parameterSegNumsIn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>last seq. id which was received </p>

</div>
</div>
<a id="a2f1348246d9c74b77cbcde3a16d04bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1348246d9c74b77cbcde3a16d04bc8">&#9670;&nbsp;</a></span>parameterSegNumsOut</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;uint16_t, uint16_t&gt; AbstractDcpManager::parameterSegNumsOut</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>last seq. id which was send out </p>

</div>
</div>
<a id="a28d9975440d2ce14eca95d246fae2bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d9975440d2ce14eca95d246fae2bd7">&#9670;&nbsp;</a></span>segNumsIn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;uint8_t, uint16_t&gt; AbstractDcpManager::segNumsIn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>last seq. id which was received </p>

</div>
</div>
<a id="a23343b0e34aa0137b95cb605fbd0434a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23343b0e34aa0137b95cb605fbd0434a">&#9670;&nbsp;</a></span>segNumsOut</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;uint8_t, uint16_t&gt; AbstractDcpManager::segNumsOut</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>last seq. id which was send out </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/slave/dcp/logic/<a class="el" href="_dcp_manager_slave_8hpp_source.html">DcpManagerSlave.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_dcp_manager_slave.html">DcpManagerSlave</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
